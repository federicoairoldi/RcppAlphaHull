# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
library(RcppAlphahull)
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 200
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 2000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my alpha-shape object retrieved starting from a delvor object has the same
# structure of the one returned by the "ashape" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - alpha:             parameter for alpha shape computation (may be fixed for each test)
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which the ashape matrices don't coincide
not.matching = c()
not.matching.size = c()
not.matching.length = c()
perc.length.diff = c()
eps = 1e-15 # tollerance for confrontation of alpha shape lengths
# up to 1e-15 lengths are the "same"
n.test = 1000
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:300, 1)
x = runif(n,0,10) # sampling points
y = runif(n,0,10)
alpha = runif(1); # sampling alpha
# calling the RcppAlphahull and alphahull function to compute the alpha shape
ascpp = RcppAlphahull::ashape(x,y,alpha)
asR = alphahull::ashape(x,y,alpha)
# check lengths
# do the alpha shapes have the same length? if not adding the test to the queue not.matching.length
if( dim(asR$edges)[1]!=0 )
perc.length.diff = c(perc.length.diff, abs( (asR$length - ascpp$length)/ascpp$length ))
else
perc.length.diff = c(perc.length.diff, 0)
# checking edges
# same number of edges? if not adding the test to the queue not.matching.size
if(dim(asR$edges)[1]!=dim(ascpp$edges)[1])
not.matching.size = c(not.matching.size, i)
# same edges for the alpha? if not adding the test to the queue of wrong tests
k = 0
if(dim(asR$edges)[1]!=0)
for(j in 1:dim(asR$edges)[1])
k = k + !(search(asR$edges[j,"ind1"], asR$edges[j,"ind2"], ascpp$edges))
if(k > 0)
not.matching = c(not.matching, i)
used.n = c(used.n, n)
}
not.matching.length = which(perc.length.diff >= eps)
rm(list = c("k", "i", "ascpp", "asR", "x", "y"))
not.matching.size
not.matching.length
not.matching
max(perc.length.diff)
library(RcppAlphahull)
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 200
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
library(RcppAlphahull)
# Federico Airoldi    matricola: 892377   codice persona: 10484065
#
# this script tests that my connection matrix retrieved from the MyGAL library has the
# same structure of the one returned by the "delvor" function of the package alphahull
#
# parameters that can be modified:
# - n:                 number of sites
# - n.test:            number of tests to be excecuted
# - set.seed(rule(i)): seed for the i-th test, one can assign any rule for the seed used to sample the
#                      points. rule(i) is a function that returns a number (even a floating point one)
#
# NB: this script is quite slow due to R inefficient allocation/problems with for cicles
require(alphahull)
require(RcppAlphahull)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("search.R")
print("executing test")
# contains those test cases in which infinite edge of delvor result are not contained
# in the MyGAL result
infedges = c()
# contains those test cases in which the number of the infinite edges of the two
# results are different
n.infedges = c()
# contains those test cases in which finite edge of delvor result are not contained
# in the MyGAL result
finedges = c()
# contains those test cases in which the number of the finite edges of the two
# results are different
n.finedges = c()
n = 50 # number of point to sample for the voronoi diagram tests (feel free to change)
n.test = 200
used.n = c() # keeps track of the number of points sampled for the different tests
for(i in 1:n.test){
if(i%%50==0) print(i) # print the number of the test on the command line (can be commented to save some time)
set.seed(i)  # setting the seed for the test (feel free to modify and set your own seed)
n = sample(50:100, 1)
x = runif(n) # sampling points
y = runif(n)
# calling the RcppAlphahull and alphahull function to compute Voronoi diagram
vorcpp = RcppAlphahull::delvor(x,y)
vorR = alphahull::delvor(x,y)
# checking infinite edges
# same number of infinite edges? if not adding the test to the queue n.infedges
if(length(which(vorcpp$mesh[, "bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1))
!= length(which(vorR$mesh[, "bp2"] == 1 | vorR$mesh[, "bp1"] == 1)))
n.infedges = c(n.infedges, i)
# same infinite edges? if not adding the test to the queue infedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 1 | vorR$mesh[, "bp1"] == 1), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 1 | vorcpp$mesh[, "bp1"] == 1), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
infedges = c(infedges, i)
# checking finite edges
# same number of finite edges? if not adding the test to the queue n.finedges
if(length(which(vorcpp$mesh[, "bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0))
!= length(which(vorR$mesh[, "bp2"] == 0 & vorR$mesh[, "bp1"] == 0)))
n.finedges = c(n.finedges, i)
# same finite edges? if not adding the test to the queue finedges
k = 0
tmp = vorR$mesh[which(vorR$mesh[,"bp2"] == 0 & vorR$mesh[, "bp1"] == 0), 1:2]
tmp2 = vorcpp$mesh[which(vorcpp$mesh[,"bp2"] == 0 & vorcpp$mesh[, "bp1"] == 0), 1:2]
for(j in 1:dim(tmp)[1])
k = k + !(search(tmp[j,"ind1"], tmp[j,"ind2"], tmp2))
if(k > 0)
finedges = c(finedges, i)
used.n = c(used.n, n)
}
rm(list = c("k", "tmp", "tmp2", "i", "vorcpp", "vorR", "x", "y"))
infedges
n.infedges
finedges
n.finedges
require(RcppAlphahull)
help(ahull)
x = runif(100)
y = runif(100)
a.hull = ahull(x, y, alpha = 0.8)
plot(a.hull)
as= ashape(x,y,0.8)
plot(as)
as= ashape(x,y,0.2)
plot(as)
as= ashape(x,y,0.05)
plot(as)
plot(alphahull::ashape(x,y,0.05))
plot(alphahull::ashape(x,y,0.05), col = 'red')
plot(as)
help(load)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
load("Data_proxy.Rdata")
load("Data_proxy.RData")
head(data_proxy)
lista = list()
lista
levels = length(unique(data_proxy["label"]))
levels
levels = length(unique(data_proxy[,"label"]))
levels
unique(data_proxy[,"label"])
for(level in 1:levels){
xy = data_proxy[which(data_proxy[3]==level),1:2]
alpha.shape = ashape(xy, alpha = )
lista = list(lista, aslpha.shape)
}
for(level in 1:levels){
xy = data_proxy[which(data_proxy[3]==level),1:2]
alpha.shape = ashape(xy, alpha = 0.5)
lista = list(lista, aslpha.shape)
}
alpha.shape = RcppAlphahul::ashape(xy, alpha = 0.85)
xy
level
data_proxy[which(data_proxy[3]==level), 1:2]
data_proxy[which(data_proxy[3]==2), 1:2]
which(data_proxy[3]==level)
xy = data_proxy[which(data_proxy["label"]==level), 1:2]
alpha.shape = RcppAlphahul::ashape(xy, alpha = 0.85)
alpha.shape = RcppAlphahu√≤ll::ashape(xy, alpha = 0.85)
alpha.shape = RcppAlphahull::ashape(xy, alpha = 0.85)
xy
xy = data_proxy[which(data_proxy[,"label"]==level), 1:2]
alpha.shape = RcppAlphahull::ashape(xy, alpha = 0.85)
lista = list(lista, aslpha.shape)
lista = list(lista, aslpha.shape)
lista = list(lista, alpha.shape)
lista
plot(aslpha.shape, col = "blue")
plot(alpha.shape, col = "blue")
xy
head(data_proxy)
princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3])[,1:2]
princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3], scores = T)
xy = princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3], scores = T)
xy
xy = princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3], scores = T)$scores[,1:2]
alpha.shape = RcppAlphahull::ashape(xy, alpha = 0.85)
plot(alpha.shape, col = "blue")
plot(alpha.shape, col = c("blue","black"))
levels = length(unique(data_proxy[,"label"]))
x11()
par(mfrow = c(2,5))
for(level in 1:levels){
xy = data_proxy[which(data_proxy[,"label"]==level), 1:2]
xy = princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3], scores = T)$scores[,1:2]
alpha.shape = RcppAlphahull::ashape(xy, alpha = 0.85)
plot(alpha.shape, col = c("blue","black"))
lista = list(lista, alpha.shape)
}
for(level in 1:levels){
xy = princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3], scores = T)$scores[,1:2]
alpha.shape = RcppAlphahull::ashape(xy, alpha = 0.85)
# plot(alpha.shape, col = c("blue","black"))
lista = list(lista, alpha.shape)
}
for(level in 1:levels){
xy = princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3], scores = T)$scores[,1:2]
alpha.shape = RcppAlphahull::ashape(xy, alpha = 0.85)
# plot(alpha.shape, col = c("blue","black"))
lista = list(lista, alpha.shape)
}
for(level in 1:levels){
xy = princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3], scores = T)$scores[,1:2]
alpha.shape = RcppAlphahull::ashape(xy, alpha = 0.5)
# plot(alpha.shape, col = c("blue","black"))
lista = list(lista, alpha.shape)
}
x = runif(10)
y = runif(10)
plot(ashape(x,y,0.3))
plot(ashape(x,y,0.2))
plot(ahull(x,y,0.2))
for(level in 1:levels){
xy = princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3], scores = T)$scores[,1:2]
alpha.hull = RcppAlphahull::ahull(xy, alpha = 0.5)
# plot(alpha.shape, col = c("blue","black"))
lista = list(lista, alpha.hull)
}
par(mfrow = c(2,5))
for(level in 1:levels){
xy = princomp(data_proxy[which(data_proxy[,"label"]==level), 1:3], scores = T)$scores[,1:2]
alpha.hull = alphahull::ahull(xy, alpha = 0.5)
# plot(alpha.shape, col = c("blue","black"))
lista = list(lista, alpha.hull)
}
devtools::document()
devtools::build_manual()
devtools::build_manual()
library(RcppAlphahull)
library(RcppAlphahull)
